<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: SceneManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: SceneManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  PerspectiveCamera,
  WebGLRenderer,
  Scene,
  Color,
  LineSegments,
  LineBasicMaterial,
  PMREMGenerator,
  sRGBEncoding,
  Vector3,
  OrthographicCamera,
  AmbientLight,
  Group,
} from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { BoxLineGeometry } from 'three/examples/jsm/geometries/BoxLineGeometry';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer';
import { DisplayElement } from './DisplayElement';
import { EXRLoader } from './EXRLoader';
import { PBRMapper } from './PBRMapper';
import { RoomEnvironment } from './RoomEnvironment';
import { required } from './utils';

export class SceneManager {
  constructor({
    cfg = required('cfg'),
    toneMapping = 4, //ACESFilmicToneMapping;
    customLights = [],
    customHandleResize = false,
  }) {
    if (cfg.sceneManager === false) {
      return;
    }
    this.fixedAspect = cfg.fixedAspect;
    this.recentered = false;

    // 1. Define renderer(s)
    this.renderer = new WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.outputEncoding = sRGBEncoding;
    this.renderer.toneMapping = toneMapping;
    document.getElementById('screen').appendChild(this.renderer.domElement);
    DisplayElement.hide(this.renderer.domElement);

    if (cfg.cssScene) {
      this.cssRenderer = new CSS2DRenderer();
      this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
      this.cssRenderer.domElement.style.position = 'absolute';
      document
        .getElementById('screen')
        .appendChild(this.cssRenderer.domElement);
      DisplayElement.hide(this.cssRenderer.domElement);
      this.cssScene = new Scene();
    }

    // 2. Create a scene
    this.scene = new Scene();
    this.scene.background = new Color(cfg.backgroundColor);

    // Create a wireframe backdrop
    if (cfg.gridRoom === true) {
      let room = new LineSegments(
        new BoxLineGeometry(6, 6, 6, 5, 5, 5).translate(0, 3, 0),
        new LineBasicMaterial({ color: 'black' })
      );
      this.scene.add(room);
    }

    // Add light using an environment map
    if (cfg.environmentLighting) {
      const pmremGenerator = new PMREMGenerator(this.renderer);
      if (cfg.environmentLighting.endsWith('.js')) {
        // Option 1: Provide a pre-built Scene object (see RoomEnvironment.js)
        this.scene.environment = pmremGenerator.fromScene(
          new RoomEnvironment(0.5),
          0.04
        ).texture;
        pmremGenerator.dispose();
      } else if (
        // Option 2: Provide a .hdr or .exr image
        cfg.environmentLighting.endsWith('.exr') ||
        cfg.environmentLighting.endsWith('.hdr')
      ) {
        let envLoader;
        if (cfg.environmentLighting.endsWith('.exr')) {
          envLoader = new EXRLoader();
        } else {
          envLoader = new RGBELoader();
        }
        envLoader.load(cfg.environmentLighting, (texture) => {
          this.scene.environment =
            pmremGenerator.fromEquirectangular(texture).texture;
          pmremGenerator.dispose();
          texture.dispose();
        });
      }
    }

    // Add your own lights
    for (let l of customLights) {
      if (l.isLight) {
        this.scene.add(l);
      }
    }

    if (!cfg.environmentLighting &amp;&amp; customLights.length === 0) {
      this.scene.add(new AmbientLight());
    }

    if (cfg.orthographic) {
      // 2. Define camera (if not added to scene, used as default by all renderers)
      this.camera = new OrthographicCamera(-1, 1, -1, 1, 0.01, 2);
      this.camera.frustumSize = 2; // bottom top = [-1, 1], left right = [-AR, AR]
      this.renderer.toneMapping = 1; // LinearMapping (for better match to CSS colors)
    } else {
      this.camera = new PerspectiveCamera(70, 1, 0.01, 10);
    }
    if (cfg.requireVR) {
      this.cameraGroup = new Group();

      this.camera.position.set(0, 1.6, 1.5);
      this.cameraGroup.add(this.camera);
      this.scene.add(this.cameraGroup);
      // this.blinder = new Mesh(
      //   new PlaneGeometry(1, 1, 1, 1),
      //   new MeshStandardMaterial({ color: 'black', transparent: true })
      // );
      // this.blinder.translateZ(-0.015);
      // this.camera.add(this.blinder);
      // this.blinder.fadeTween = new Tween(this.blinder)
      //   .to({ material: { opacity: 0 } }, 500)
      //   .onComplete((o) => (o.visible = false));
    } else {
      this.camera.position.set(0, 0, 1);
    }

    // Add resize listener
    // for consistent scene scale despite window dimensions (see also handleResize):
    // tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
    // windowHeight = window.innerHeight;
    let callback = (customHandleResize || this.handleResize).bind(this);
    window.addEventListener('resize', callback);
    callback();

    // Orbit controls
    if (cfg.orbitControls) {
      this.orbitControls = new OrbitControls(
        this.camera,
        this.cssRenderer?.domElement || this.renderer.domElement
      );
      let targ = cfg.homePosn ?? new Vector3();
      this.orbitControls.target.set(...targ);
      this.orbitControls.update();
      this.orbitControls.listenToKeyEvents(window); // enable arrow keys
      this.orbitControls.enableDamping = true;
      this.orbitControls.keys = {
        LEFT: 'KeyA', //'ArrowLeft', //left arrow
        UP: 'KeyW', //'ArrowUp', // up arrow
        RIGHT: 'KeyD', //'ArrowRight', // right arrow
        BOTTOM: 'KeyS', //'ArrowDown' // down arrow
      };
    }

    // Prepare texture loader
    this.pbrMapper = new PBRMapper();
  }

  handleResize() {
    this.camera.aspect =
      this.fixedAspect || window.innerWidth / window.innerHeight;
    // for consistent scene scale despite window dimensions (see also constructor...)
    // camera.fov =
    //   (360 / Math.PI) *
    //   Math.atan(
    //     this.cfg.tanFOV * (window.innerHeight / this.cfg.windowHeight)
    //   );
    if (this.camera.isOrthographicCamera) {
      this.camera.left = (-this.camera.frustumSize * this.camera.aspect) / 2;
      this.camera.right = (this.camera.frustumSize * this.camera.aspect) / 2;
      this.camera.top = this.camera.frustumSize / 2;
      this.camera.bottom = -this.camera.frustumSize / 2;
    }
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.cssRenderer?.setSize(window.innerWidth, window.innerHeight);
  }

  render() {
    this.orbitControls?.update();
    this.renderer.render(this.scene, this.camera);
    this.cssRenderer?.render(this.cssScene, this.camera);
    if (!this.recentered &amp;&amp; this.renderer.xr.isPresenting) {
      this.recenter();
    }
  }

  recenter() {
    this.clearCameraOffset();
    // Get camera direction
    let camDir = this.camera.getWorldDirection(new Vector3());
    // Get camera angle with respect to world -Z
    let theta = Math.atan2(-camDir.x, -camDir.z);
    // Rotate camera group at origin so the camera faces down world -Z
    this.cameraGroup.rotateY(-theta);
    // Get XZ world vector that would bring the rotated camera to the origin
    let camVec = this.camera.getWorldPosition(new Vector3()).setY(0).negate();
    let len = camVec.length(); // store the non-normalized length
    // Transform XZ world vector into rotated camera group coordinates
    // Normalize in case it matters
    this.cameraGroup.worldToLocal(camVec).normalize();
    // Apply to cameraGroup
    this.cameraGroup.translateOnAxis(camVec, len);
    this.recentered = true;
  }

  /**
   *
   */
  clearCameraOffset() {
    // Clear
    this.cameraGroup.position.set(0, 0, 0);
    this.cameraGroup.lookAt(0, 0, 1);
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BlockOptions_BlockOptions.html">BlockOptions</a></li><li><a href="Consent.html">Consent</a></li><li><a href="DisplayElement.html">DisplayElement</a></li><li><a href="Experiment_Experiment.html">Experiment</a></li><li><a href="Fullscreen.html">Fullscreen</a></li><li><a href="Goodbye.html">Goodbye</a></li><li><a href="MeshFactory.html">MeshFactory</a></li><li><a href="PBRMapper.html">PBRMapper</a></li><li><a href="Pointerlock.html">Pointerlock</a></li><li><a href="Progressbar.html">Progressbar</a></li><li><a href="SpiralCurve.html">SpiralCurve</a></li><li><a href="Survey.html">Survey</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkAlignment">checkAlignment</a></li><li><a href="global.html#computeMassSpringDamperParameters">computeMassSpringDamperParameters</a></li><li><a href="global.html#computeMassSpringDamperPosition">computeMassSpringDamperPosition</a></li><li><a href="global.html#generateDemoReaches">generateDemoReaches</a></li><li><a href="global.html#quantizeAngle">quantizeAngle</a></li><li><a href="global.html#randomNumericString">randomNumericString</a></li><li><a href="global.html#randomVectorFromCone">randomVectorFromCone</a></li><li><a href="global.html#required">required</a></li><li><a href="global.html#rotationHelper">rotationHelper</a></li><li><a href="global.html#rotationalClamp">rotationalClamp</a></li><li><a href="global.html#truncQuadCost">truncQuadCost</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Mar 27 2023 11:46:07 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
